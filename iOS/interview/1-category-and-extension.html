<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>陈希的学习笔记</title><meta name="description" content="">
    <link rel="modulepreload" href="/blog/assets/app.01142347.js"><link rel="modulepreload" href="/blog/assets/1-category-and-extension.html.5a4bd445.js"><link rel="modulepreload" href="/blog/assets/1-category-and-extension.html.3b5530c5.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/blog/assets/style.72ef85ec.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt="陈希的学习笔记"><span class="site-name can-hide">陈希的学习笔记</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/java/" class="" aria-label="Android"><!--[--><!--]--> Android <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/iOS/" class="router-link-active" aria-label="iOS"><!--[--><!--]--> iOS <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/shell/" class="" aria-label="Shell"><!--[--><!--]--> Shell <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/data-structure/" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/database/" class="" aria-label="数据库"><!--[--><!--]--> 数据库 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/Vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/others/" class="" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/chenxi92/blog.git" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/java/" class="" aria-label="Android"><!--[--><!--]--> Android <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/iOS/" class="router-link-active" aria-label="iOS"><!--[--><!--]--> iOS <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/shell/" class="" aria-label="Shell"><!--[--><!--]--> Shell <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/data-structure/" class="" aria-label="数据结构"><!--[--><!--]--> 数据结构 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/database/" class="" aria-label="数据库"><!--[--><!--]--> 数据库 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/Vue/" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/others/" class="" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/chenxi92/blog.git" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/blog/iOS/" class="router-link-active sidebar-item sidebar-heading active" aria-label="iOS"><!--[--><!--]--> iOS <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/iOS/swift-concurrency.md" class="sidebar-item" aria-label="Swift Concurrency"><!--[--><!--]--> Swift Concurrency <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/app-launch.md" class="sidebar-item" aria-label="App 启动"><!--[--><!--]--> App 启动 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/attribute.md" class="sidebar-item" aria-label="attribute"><!--[--><!--]--> attribute <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/autolayout.md" class="sidebar-item" aria-label="AutoLayout 布局"><!--[--><!--]--> AutoLayout 布局 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/bug-track.md" class="sidebar-item" aria-label="Bug 追踪"><!--[--><!--]--> Bug 追踪 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/create-certificate.md" class="sidebar-item" aria-label="创建开发证书"><!--[--><!--]--> 创建开发证书 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/dispatch-semaphore.md" class="sidebar-item" aria-label="信号量"><!--[--><!--]--> 信号量 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/install-ipa-from-safari.md" class="sidebar-item" aria-label="iPA 文件安装"><!--[--><!--]--> iPA 文件安装 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/isa.md" class="sidebar-item" aria-label="isa 指针"><!--[--><!--]--> isa 指针 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/keychain.md" class="sidebar-item" aria-label="钥匙串学习"><!--[--><!--]--> 钥匙串学习 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/libmobiledevice.md" class="sidebar-item" aria-label="libmobiledevice"><!--[--><!--]--> libmobiledevice <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/method-forward.md" class="sidebar-item" aria-label="消息转发"><!--[--><!--]--> 消息转发 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/multiple-thread.md" class="sidebar-item" aria-label="多线程"><!--[--><!--]--> 多线程 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/security.md" class="sidebar-item" aria-label="security"><!--[--><!--]--> security <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/symbols.md" class="sidebar-item" aria-label="符号表"><!--[--><!--]--> 符号表 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/tips.md" class="sidebar-item" aria-label="iOS 开发小知识"><!--[--><!--]--> iOS 开发小知识 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/UIScrollview.md" class="sidebar-item" aria-label="UIScrollView 约束"><!--[--><!--]--> UIScrollView 约束 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/2-unity-ios-bridge.md" class="sidebar-item" aria-label="iOS &amp; Unity 相互调用"><!--[--><!--]--> iOS &amp; Unity 相互调用 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/vapor-tutorial.md" class="sidebar-item" aria-label="Vapor 学习"><!--[--><!--]--> Vapor 学习 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/xcode-shortcut.md" class="sidebar-item" aria-label="Xcode 快捷键"><!--[--><!--]--> Xcode 快捷键 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/configure-alternate-app-icon.md" class="sidebar-item" aria-label="Configure Alternate App Icon"><!--[--><!--]--> Configure Alternate App Icon <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/sending-push-notification.md" class="sidebar-item" aria-label="Sending Push Notifications"><!--[--><!--]--> Sending Push Notifications <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/how-to-create-dmg.md" class="sidebar-item" aria-label="How to create dmg file"><!--[--><!--]--> How to create dmg file <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/how-to-test-static-framework/how-to-test-static-framework.md" class="sidebar-item" aria-label="How to test static framework"><!--[--><!--]--> How to test static framework <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/download-xcappdata-folder.md" class="sidebar-item" aria-label="How to download xcappdata folder"><!--[--><!--]--> How to download xcappdata folder <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item">Keywords <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/iOS/SwiftKeywords/dynamicCallable.md" class="sidebar-item" aria-label="dynamicCallable"><!--[--><!--]--> dynamicCallable <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/blog/iOS/ios-app-preorder.md" class="sidebar-item" aria-label="iOS App Pre-Order"><!--[--><!--]--> iOS App Pre-Order <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item active">面试 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/iOS/interview/0-interview-question.md" class="sidebar-item" aria-label="面试题"><!--[--><!--]--> 面试题 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/interview/1-category-and-extension.md" class="sidebar-item active" aria-label="Category &amp; Extension"><!--[--><!--]--> Category &amp; Extension <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/interview/2-atomic.md" class="sidebar-item" aria-label="原子性"><!--[--><!--]--> 原子性 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/interview/3-weak.md" class="sidebar-item" aria-label="Weak"><!--[--><!--]--> Weak <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/interview/4-associated-object.md" class="sidebar-item" aria-label="关联对象"><!--[--><!--]--> 关联对象 <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/interview/property.md" class="sidebar-item" aria-label="属性"><!--[--><!--]--> 属性 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item">源码学习 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/blog/iOS/open-analysis/AFNetworking.md" class="sidebar-item" aria-label="AFNetworking"><!--[--><!--]--> AFNetworking <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/open-analysis/Aspects.md" class="sidebar-item" aria-label="Aspects"><!--[--><!--]--> Aspects <!--[--><!--]--></a><!----></li><li><a href="/blog/iOS/open-analysis/Masonry.md" class="sidebar-item" aria-label="Masonry"><!--[--><!--]--> Masonry <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><h4 id="category" tabindex="-1"><a class="header-anchor" href="#category" aria-hidden="true">#</a> Category</h4><blockquote><p>是OC中的特有语法，它是表示一个指向分类的结构体的指针。原则上它只能增加方法，不能增加成员（实例）变量。</p></blockquote><h5 id="形式" tabindex="-1"><a class="header-anchor" href="#形式" aria-hidden="true">#</a> 形式</h5><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface MyClass (MyCatetory)
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h5><ul><li>分类是用于给原有类添加方法的, 因为分类的结构体指针中，没有属性列表，只有方法列表。所以原则上讲它只能添加方法, 不能添加属性(成员变量), 实际上可以通过其它方式添加属性;</li><li>分类中的可以写 <code>@property</code>, 但不会生成 <code>setter</code> 和 <code>getter</code> 方法, 也不会生成实现以及私有的成员变量（<code>编译时会报警告</code>）;</li><li>可以在分类中访问原有类中 <code>.h</code> 中的属性;</li><li>如果分类中有和原有类同名的方法, 会优先调用分类中的方法, 就是说会忽略原有类的方法。所以同名方法调用的优先级为 <code>分类 &gt; 本类 &gt; 父类</code>。因此在开发中尽量不要覆盖原有类;</li><li>如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定；编译器会执行最后一个参与编译的分类中的方法。</li></ul><p>在一个类中用 <code>@property</code> 声明属性，编译器会自动帮我们生成 <code>_成员变量</code>、 <code>setter</code> 和 <code>getter</code> 方法，</p><p>但分类的指针结构体中根本没有属性列表，所以在分类中用 <code>@property</code> 声明属性无法帮生成 <code>_成员变量</code>、 <code>setter</code> 和 <code>getter</code> 方法</p><p>因此结论是：我们可以用 <code>@property</code> 声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。但如果调用了 <code>_成员变量</code> 和 <code>setter</code> 和 <code>getter</code> 方法，报错就在所难免了。</p><p><code>Category</code> 是表示一个指向分类的结构体的指针，其定义如下：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>typedef struct objc_category *Category;
struct objc_category {
  char *category_name                          OBJC2_UNAVAILABLE; // 分类名
  char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名
  struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表
  struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表
  struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="extension" tabindex="-1"><a class="header-anchor" href="#extension" aria-hidden="true">#</a> Extension</h4><blockquote><p>Extension是Category的一个特例。 类扩展与分类相比只少了分类的名称，所以称之为“匿名分类”。</p></blockquote><h5 id="形式-1" tabindex="-1"><a class="header-anchor" href="#形式-1" aria-hidden="true">#</a> 形式</h5><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface XXX ()
//私有属性
//私有方法（如果不实现，编译时会报警,Method definition for &#39;XXX&#39; not found）
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1" aria-hidden="true">#</a> 作用</h5><ul><li>为一个类添加额外的原来没有变量，方法和属性</li><li>一般的类扩展写到.m文件中</li><li>一般的私有属性写到.m文件中的类扩展中</li></ul><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h4><ul><li>分类中原则上只能增加方法（能添加属性的的原因是通过 runtime 解决无 setter 和 getter 方法的问题）；</li><li>扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（ 用范围只能在自身类，而不是子类或其他地方）；</li><li>类扩展中声明的方法没被实现，编译器会报警，但是分类中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而分类是在运行时添加到类中。(<code>Xcode9 也会警告</code>)</li><li>类扩展不能像分类那样拥有独立的实现部分（<code>@implementation</code> 部分），类扩展所声明的方法必须依托<strong>对应类</strong>的实现部分来实现。</li><li>定义在 <code>.m</code> 文件中的类扩展方法为私有的，定义在 <code>.h</code> 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。</li></ul><h3 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题" aria-hidden="true">#</a> 常见问题</h3><h4 id="_1-分类为什么会覆盖掉类的同名方法-对应的类方法是不存在了么" tabindex="-1"><a class="header-anchor" href="#_1-分类为什么会覆盖掉类的同名方法-对应的类方法是不存在了么" aria-hidden="true">#</a> 1. 分类为什么会覆盖掉类的同名方法，对应的类方法是不存在了么？</h4><p>category 没有 <strong>完全替换掉</strong> 原来类已经有的方法，也就是说如果 category 和原来类都有 methodA ，那么 category 附加完成之后，类的方法列表里会有两个methodA;</p><p>category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面;</p><p>这也就是我们平常所说的 category 的方法会 <strong>覆盖</strong> 掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法就会罢休，殊不知后面可能还有一样名字的方法。</p><h4 id="_2-怎么解除分类对类方法的覆盖" tabindex="-1"><a class="header-anchor" href="#_2-怎么解除分类对类方法的覆盖" aria-hidden="true">#</a> 2. 怎么解除分类对类方法的覆盖？</h4><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>/**
怎么调用到原来类中被 category 覆盖掉的方法？
对于这个问题，我们已经知道 category 其实并不是完全替换掉原来类的同名方法，只是 category 在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：
*/
+ (void)useClassMethodInsteadCayegoryMethod:(SEL)seletor {
    
    if (self) {
        unsigned int methodCount;
        Method *methodList = class_copyMethodList([self class], &amp;methodCount);
        IMP lastImp = NULL;
        SEL lastSel = NULL;
        for (NSInteger i = 0; i &lt; methodCount; i++) {
            Method method = methodList[i];
            NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))
                                                      encoding:NSUTF8StringEncoding];
            NSString *selectorName = NSStringFromSelector(seletor);
            if ([selectorName isEqualToString:methodName]) {
                lastImp = method_getImplementation(method);
                lastSel = method_getName(method);
            }
        }
        typedef void (*fn)(id,SEL);
        
        if (lastImp != NULL) {
            fn f = (fn)lastImp;
            f(self,lastSel);
        }
        free(methodList);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h4 id="_3-category关联对象" tabindex="-1"><a class="header-anchor" href="#_3-category关联对象" aria-hidden="true">#</a> 3. category关联对象</h4><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>#import &lt;Foundation/Foundation.h&gt;
#import &quot;LearnCategoryClass.h&quot;

@interface LearnCategoryClass (Addition)
@property(nonatomic, strong) NSString *newName;
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>#import &quot;LearnCategoryClass+Addition.h&quot;
#import &lt;objc/runtime.h&gt;

@implementation LearnCategoryClass (Addition)

//运行时动态添加 set 和 get 方法
- (void)setNewName:(NSString *)newName
{
    objc_setAssociatedObject(self,
                             &quot;newName&quot;,
                             newName,
                             OBJC_ASSOCIATION_COPY);
}

- (NSString*)newName
{
    NSString *nameObject = objc_getAssociatedObject(self, &quot;newName&quot;);
    return nameObject;
}
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="_4-多个category-哪个方法优先执行" tabindex="-1"><a class="header-anchor" href="#_4-多个category-哪个方法优先执行" aria-hidden="true">#</a> 4. 多个category，哪个方法优先执行？</h4><p>加载 <code>category</code> 到类的工作会先于<code>+load</code> 方法的执行；</p><p><code>+load</code> 方法执行的循序是先 <code>class</code>，后 <code>category</code>，多个 <code>category</code> 的 <code>+load</code> 方法的执行顺序是根据编译顺序决定的。</p><h3 id="category-特性在-ios-组件化中的应用与管控" tabindex="-1"><a class="header-anchor" href="#category-特性在-ios-组件化中的应用与管控" aria-hidden="true">#</a> Category 特性在 iOS 组件化中的应用与管控</h3><h5 id="实际业务案例" tabindex="-1"><a class="header-anchor" href="#实际业务案例" aria-hidden="true">#</a> 实际业务案例</h5><blockquote><p>例1：外卖的首页的商家列表（WMPageKit），在进入一个商家（WMRestaurantKit）选择5件商品返回到首页的时候，对应的商家cell需要显示已选商品“5”。</p></blockquote><blockquote><p>例2：搜索结果（WMSearchKit）跳转到商超的容器页（WMSupermarketKit），需要传递一个通用Domain（也有的说法叫模型、Model、Entity、Object等等，下文统一用Domain表示）。</p></blockquote><blockquote><p>例3：做一键下单需求（WMPageKit），需要调用下单功能的一个方法（WMOrderKit）入参是一个订单相关 Domain 和一个 VC，不需要返回值。</p></blockquote><p>这几种场景基本涵盖了组件通信所需的的基本功能，那么怎样才可以实现最优雅的解决方案？</p><h5 id="组件通信方案" tabindex="-1"><a class="header-anchor" href="#组件通信方案" aria-hidden="true">#</a> 组件通信方案</h5><h5 id="_1-category-nsinvocation方案" tabindex="-1"><a class="header-anchor" href="#_1-category-nsinvocation方案" aria-hidden="true">#</a> 1. Category+NSInvocation方案</h5><p>这个方案将其对 NSInvocation 功能容错封装、参数判断、类型转换的代码写在下层，提供简易万能的接口。并在上层创建通信调度器类提供常用接口，在调度器的的 Category 里扩展特定业务的专用接口。所有的上层接口均有规范约束，这些规范接口的内部会调用下层的简易万能接口即可通过NSInvocation 相关的硬编码操作调用任何方法。</p><p><img src="https://p0.meituan.net/travelcube/1a59d7f90ea57058226929a3f9aab257133322.png" alt="UML图"></p><p>示例代码:</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler+AKit.h
#import &quot;WMScheduler.h&quot;
@interface WMScheduler(AKit)
/**
 * 通过商家id查到当前购物车已选e的小红点数量
 * @param poiid  商家id
 * @return 实际的小红点数量
 */
+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID;
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler+AKit.m
#import &quot;WMSchedulerCore.h&quot;
#import &quot;WMScheduler+AKit.h&quot;
#import &quot;NSObject+WMScheduler.h&quot;
@implementation WMScheduler (AKit)
+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID{
    if (nil == poiid) {
        return 0;
    }
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;
    id singleton = [wm_scheduler_getClass(&quot;WMXXXSingleton&quot;) wm_executeMethod:@selector(sharedInstance)];
    NSNumber* orderFoodCount = [singleton wm_executeMethod:@selector(calculateOrderedFoodCountWithPoiID:) params:@[poiID]];
    return orderFoodCount == nil ? 0 : [orderFoodCount integerValue];
#pragma clang diagnostic pop
}
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMSchedulerInterfaceList.h
#ifndef WMSchedulerInterfaceList_h
#define WMSchedulerInterfaceList_h
// 这个文件会被加到上层业务的pch里，所以下文不用import本文件
#import &quot;WMScheduler.h&quot;
#import &quot;WMScheduler+AKit.h&quot;
#endif /* WMSchedulerInterfaceList_h */
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>BKit （调用方）一个文件：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMHomeVC.m
@interface WMHomeVC () &lt;UITableViewDataSource, UITableViewDelegate&gt;
@end
@implementation WMHomeVC
...
    NSUInteger *foodCount = [WMScheduler wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];
    NSLog(@&quot;%ld&quot;,foodCount);
...
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>阶段总结：</strong></p><p>Category+NSInvocation 方案的优点是便捷，因为 Category 的专用接口放在平台库，以后有除了 BKit 以外的其他调用方也可以直接调用，还有更多强大的功能。</p><p>但是，不优雅的地方我们也列举一下：</p><ul><li>当这个跨组件方法内部的代码行数比较多时，会写很多硬编码。</li><li>硬编码method字符串，在现有方法被修改时，编译检测不报错（只能靠断言约束）。</li><li>下层库向上调用的设计会被诟病。</li></ul><h5 id="_2-categorycoverorigin方案" tabindex="-1"><a class="header-anchor" href="#_2-categorycoverorigin方案" aria-hidden="true">#</a> 2. CategoryCoverOrigin方案</h5><p><strong>方案简介：</strong></p><p>首先说明下这个方案和 NSInvocation 没有任何关系，此方案与上一方案也是完全不同的两个概念，不要将上一个方案的思维带到这里。</p><p>此方案的思路是在平台层的 WMScheduler.h 提供接口方法，接口的实现只写空实现或者兜底实现（兜底实现中可根据业务场景在 Debug 环境下增加 toast 提示或断言），上层库的提供方实现接口方法并通过 Category 的特性，在运行时进行对基类同名方法的替换。</p><p>调用方则正常调用平台层提供的接口。在 CategoryCoverOrigin 的方案中 WMScheduler 的 Category 在提供方仓库内部，因此业务逻辑的依赖可以在仓库内部使用常规的OC调用。</p><p><img src="https://p0.meituan.net/travelcube/577bb3b451cc26f621fbedc15118e3dc95493.png" alt="UML"></p><p>平台（通用功能库）两个文件</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>//  WMScheduler.h
@interface WMScheduler : NSObject
//  这个文件是所有组件通信方法的汇总
#pragma mark - AKit  
/**
 * 通过商家id查到当前购物车已选e的小红点数量
 * @param poiid  商家id
 * @return 实际的小红点数量
 */
+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID;
#pragma mark - CKit
// ...
#pragma mark - DKit
// ...
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler.m
#import &quot;WMScheduler.h&quot;
@implementation WMScheduler
#pragma mark - Akit
+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID
{
		return 0; // 这个.m里只要求一个空实现 作为兜底方案。
}
#pragma mark - Ckit
// ...
#pragma mark - Dkit
// ...
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>AKit（提供方）一个 Category 文件：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler+AKit.m
#import &quot;WMScheduler.h&quot;
#import &quot;WMAKitBusinessManager.h&quot;
#import &quot;WMXXXSingleton.h&quot;  
// 直接导入了很多AKit相关的业务文件，因为本身就在AKit仓库内
@implementation WMScheduler (AKit)
// 这个宏可以屏蔽分类覆盖基类方法的警告
#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Wobjc-protocol-method-implementation&quot;
// 在平台层写过的方法，这边是是自动补全的
+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID
{
  	if (nil == poiid) {
        return 0;
    }
  	// 所有AKIT相关的类都能直接接口调用，不需要任何硬编码，可以和之前的写法对比下。
    WMXXXSingleton *singleton = [WMXXXSingleton sharedInstance];
    NSNumber *orderFoodCount = [singleton calculateOrderedFoodCountWithPoiID:poiID];
    return orderFoodCount == nil ? 0 : [orderFoodCount integerValue];
}
#pragma clang diagnostic pop
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>BKit（调用方） 一个文件写法不变：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMHomeVC.m
@interface WMHomeVC () &lt;UITableViewDataSource, UITableViewDelegate&gt;
@end
@implementation WMHomeVC
...
    NSUInteger *foodCount = [WMScheduler wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];
    NSLog(@&quot;%ld&quot;,foodCount);
...
@end
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>两种方案的选择</p><table><thead><tr><th>比较</th><th>Category+NSInvocation</th><th>CategoryCover</th></tr></thead><tbody><tr><td>优点</td><td>1. 只改两个仓库，流程上的时间成本更少；<br>2. 可以实现url调用方法（scheme://target/method:?para=x）</td><td>1. 无任何硬编码，常规OC接口调用；<br>2. 除了接口声明、分类覆盖、调用，没有其他多余代码；不存在下层调用上层的场景</td></tr><tr><td>缺点</td><td>1. 功能复杂时硬编码写法成本较大；<br>2. 下层调上层，上层业务改变时会影响平台接口</td><td>1. 不能使用url调用方法；<br> 2. 新增接口时需改动三个仓库，稍有麻烦。（当接口已存在时，两种方式都只需修改一处）</td></tr></tbody></table><p><strong>内容来源:</strong></p><p><a href="https://www.jianshu.com/p/9e827a1708c6" target="_blank" rel="noopener noreferrer">1. iOS分类(category),类扩展(extension)—史上最全攻略<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://www.jianshu.com/p/a057936e0dac" target="_blank" rel="noopener noreferrer">2. category的高级使用<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://tech.meituan.com/2018/11/08/ios-category-module-communicate.html" target="_blank" rel="noopener noreferrer">3. Category 特性在 iOS 组件化中的应用与管控<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/chenxi92/blog.git/edit/main/iOS/interview/1-category-and-extension.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新时间: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: peak@jiemogame.com">peak</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.01142347.js" defer></script>
  </body>
</html>
